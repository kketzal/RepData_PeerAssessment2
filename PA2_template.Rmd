---
title: "Reproducible Research: Peer Assessment 2"
output: 
  html_document:
    keep_md: true
---


# **Title**

## Types of weather events that are most harmful with respect to population health and with respect to economic consequences

# **Synopsis**


# **Data Processing**


## Loading and preprocessing the data
  
### 1. Downloading/loading "Storm Data" file and reading the CSV file

```{r  echo=TRUE, cache=TRUE}
# suppressPackageStartupMessages(library(data.table))

## I need to change my LOCALE (spanish) to English...
Sys.setlocale('LC_TIME', 'en_US.UTF-8')

compressedFileName <- "repdata_data_StormData.csv.bz2"

URL <- "https://d396qusza40orc.cloudfront.net/repdata%2Fdata%2FStormData.csv.bz2"


# If file doesn't exist in current working directory, I try to download from website
if(!file.exists(compressedFileName))
    download.file(URL, compressedFileName)

# If the file doesn't exist in current working directory after downloading, there are any
# problem downloading this file, or there are any other problem...aborting
if(!file.exists(compressedFileName))    
    stop("Required file doesn't exist in the current working directory! Aborting...")
    
# loading data
data <- read.csv(compressedFileName)

# Get the column names and check if they are properly formatted
colnames(data) <- make.names(colnames(data))

```

```{r echo=TRUE}

head(data)
```

### 2. Storm Data - Exploratory analysis 

There is some documentation of this dataset available [here](https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf). 
More information can be obtained from the [NOAA Storm Events Database](http://www.ncdc.noaa.gov/stormevents/ftp.jsp). 

There are **`r nrow(data)` rows** or observations and **`r ncol(data)` columns** or variables in this dataset.

Reading these two websites above and, for the topic of this paper, we can subset the *data* CSV file extracting only the following columns or variables:   

* BGN_DATE (event start date)
* STATE (the USA state where event occurs)
* EVTYPE (climatic event)
* FATALITIES (numerical value for an occurrence of death)
* INJURIES (numerical value for non fatal damage, hurt, harm, ...)
* PROPDMG (numerical value for property damage)
* PROPDMGEXP (value for adjusting PROPDMG value)
* CROPDMG (numerical value for crop damage)
* CROPDMGEXP (value for adjusting CROPDMG value)

The others columns or variables aren't important for the analysis in this article.

Now, we are going to subset the dataset.

```{r echo=TRUE, cache=TRUE, message=FALSE, warning=FALSE}
suppressPackageStartupMessages(library(dplyr))

# select only the variables we are interested in
sub_data <- data %>% select(BGN_DATE, STATE, EVTYPE, FATALITIES, INJURIES, PROPDMG, PROPDMGEXP,CROPDMG, CROPDMGEXP)

# For saving computer resources, we can remove the initial dataset
rm(data)

# now, we have a smaller dataset
head(sub_data)
```
At this moment, There are **`r nrow(sub_data)` rows** or observations and **`r ncol(sub_data)` columns** or variables in *sub_data* dataset.
For this analysis we want to study types of weather events that are most harmful with respect to population health and with respect to economic consequences, so we want dataset observations with values over "0" (zero) in the following variables: FATALITIES, INJURIES, PROPDMG and CROPDMG.

```{r echo=TRUE, cache=TRUE}

sub_data <- sub_data %>% filter(FATALITIES > 0 | INJURIES > 0 | PROPDMG > 0 | CROPDMG > 0)

```

Now, there are **`r nrow(sub_data)` rows** or observations and **`r ncol(sub_data)` columns** or variables in *sub_data* dataset. We have reduced the data size significantly.

```{r echo=TRUE, cache=TRUE}
#summary of our dataset
summary(sub_data)

```

### 3. Storm Data - Cleaning the Data

In the official documentation, [here](https://d396qusza40orc.cloudfront.net/repdata%2Fpeer2_doc%2Fpd01016005curr.pdf), we can read that there are 48 event types (chapter 7, points from 7.1 to 7.48, or the Storm Data Event Table in the page 6 of the above PDF document), and we have `r length(levels(sub_data$EVTYPE))` event types in our dataset. We'll need to transform and reduce them. 

In first place, we are going to know how many ocurrences of each event type there are in our *sub_data* dataset.

```{r echo=TRUE, cache=TRUE}
summary(sub_data$EVTYPE)
```

In this summary, we can see that THUNDERSTORM WIND and other variations of the same climatic event are the more common (TSTM WIND, THUNDERSTORM WINDS, THUNDERSTORM WINDSS, THUNDERSTORM, TSTM WIND (G45), THUNDERSTORM WINDS/HAIL, WINDS, GUSTY WINDS). The idea is to group these events in one big group with name **THUNDERSTORM WIND**, like this event is named in the official documentation. We'll do the same process for others climatic events with similar variable name in our dataset. This way we reduce the dataset dimensions.

Also, there are duplicate event names, and the same event name in lowercase and in uppercase, so we'll transform all event names to uppercase, for grouping purpouses.

```{r echo=TRUE, cache=TRUE}

# Transform all event names to UPPERCASE. This transform the column "as.character".
sub_data <- mutate(sub_data, EVTYPE = as.factor(toupper(EVTYPE)))

```


We are going to group similar climatic events that can be repetitive or similar events, like THUNDERSTORM WIND or TSTM WIND, for reduce this dataset. For this purpouse, the following "groupingFactorLevels" function replaces the terms passed in the "arrayNames" parameter with the term passed in the "keyName" parameter.

```{r echo=TRUE, cache=TRUE}

groupingFactorLevels <- function(mydata, keyName, arrayNames) 
{
# searching by terms inside arrayNAmes parameter
toMatch <- arrayNames

# get the indices where there are matches
indices <- grep(paste(toMatch, collapse="|"), levels(mydata$EVTYPE))


# replacement matches with keyName parameter
levels(mydata$EVTYPE)[c(indices)] <- keyName

return(mydata)

}

```


We are going to use the above function for grouping the most important climatic events, that is, the most frequent climatic events (as you can see in: summary(sub_data$EVTYPE))

```{r echo=TRUE, cache=TRUE, message=FALSE, warning=FALSE}

toMatch <-c("TORNADO", "TORNADOES")
sub_data <- groupingFactorLevels(sub_data, c("TORNADO"), toMatch)

toMatch <- c("^THUNDERSTORM", "^TSTM", "^SEVERE THUNDERSTORM", "^THUNDERTORM WINDS", "^TSTM WIND ")
sub_data <- groupingFactorLevels(sub_data, c("THUNDERSTORM WIND"), toMatch)

toMatch <-c("^MARINE TSTM WIND", "^MARINE THUNDERSTORM WIND" )
sub_data <- groupingFactorLevels(sub_data, c("MARINE THUNDERSTORM WIND"), toMatch)

toMatch <-c("HURRICANE", "TYPHOON", "HURRICANE/TYPHOON")
sub_data <- groupingFactorLevels(sub_data, c("HURRICANE/TYPHOON"), toMatch)

toMatch <-c("RIVER FLOOD", "URBAN/SMALL STREAM FLOOD", "URBAN FLOODING", "MAJOR FLOOD", 
            "URBAN FLOOD", "URBAN/SML STREAM FLD", "FLOOD/RAIN/WINDS", "^FLOODS$")
sub_data <- groupingFactorLevels(sub_data, c("FLOOD"), toMatch)

toMatch <-c("FLASH FLOOD", "FLASH FLOODING", "FLOODING", "FLASH FLOODS")
sub_data <- groupingFactorLevels(sub_data, c("FLASH FLOOD"), toMatch)

toMatch <-c("LIGHT FREEZING RAIN", "FREEZE", "FREEZING RAIN", "FROST/FREEZE", 
           "AGRICULTURAL FREEZE", "FREEZING RAIN/SNOW", "DAMAGING FREEZE", "FREEZING DRIZZLE", 
           "FROST", "SNOW FREEZING RAIN")
sub_data <- groupingFactorLevels(sub_data, c("FROST/FREEZE"), toMatch)

toMatch <-c("^COLD$", "^WIND CHILD$", "$COLD/WIND CHILL$")
sub_data <- groupingFactorLevels(sub_data, c("COLD/WIND CHILL"), toMatch)

toMatch <-c("SNOW") 
sub_data <- groupingFactorLevels(sub_data, c("HEAVY SNOW"), toMatch)

toMatch <-c("HAIL") 
sub_data <- groupingFactorLevels(sub_data, c("HAIL"), toMatch)

# This new data type is to summarize... 
toMatch <-c("FOG") 
sub_data <- groupingFactorLevels(sub_data, c("DENSE/FREEZING FOG"), toMatch)

toMatch <-c("HEAT") 
sub_data <- groupingFactorLevels(sub_data, c("HEAT/EXCESSIVE HEAT"), toMatch)

summary(sub_data$EVTYPE)
```

The most important climatic events are summarized in the above list, and for the purpouse of this article, it is enough.

### 4. Storm Data - Summarizing the Data

Now, we have two different questions to resolve:

> 1. Weather events that are most harmful with respect to population health
> 2. Weather events that are most harmful with respect to economic consequences

The climatic events that affect the first question may not be the same that affect the second question and vice versa.

For this purpouse, we need to extract these differents observations from the *sub_data* dataset. One dataset for population health, and another dataset for economic consequences.

```{r echo=TRUE, cache=TRUE}
sub_data_health <- sub_data %>% filter(FATALITIES > 0 | INJURIES > 0)
sub_data_economic <- sub_data %>% filter(PROPDMG > 0 | CROPDMG > 0)

# For saving computer resources, we can remove the initial dataset
rm(sub_data)
```

Now, there are **`r nrow(sub_data_health)` rows** or observations and **`r ncol(sub_data_health)` columns** or variables in *sub_data_health* dataset, and  **`r nrow(sub_data_economic)` rows** or observations and **`r ncol(sub_data_economic)` columns** or variables in *sub_data_economic* dataset.

At this point, we are going to check the more harmful event types in our datasets.

```{r echo=TRUE, cache=TRUE}

# Group by event type
my_health_group <- group_by(sub_data_health, EVTYPE)

# Get the sum of injuries and fatalities by event type

my_health_summary_fatalities <- summarise(my_health_group, sum(FATALITIES))
my_health_summary_injuries <- summarise(my_health_group, sum(INJURIES))
my_health_total_summary <- summarise(my_health_group, sum(FATALITIES),sum(INJURIES), 
                                     TOTAL = sum(FATALITIES) + sum(INJURIES))

# change tne column names
colnames(my_health_summary_fatalities) <- c("EVTYPE", "SUM_FATALITIES")
colnames(my_health_summary_injuries) <- c("EVTYPE", "SUM_INJURIES")
colnames(my_health_total_summary) <- c("EVTYPE", "SUM_FATALITIES", "SUM_INJURIES", "TOTAL")

# Order the dataset by number of FATALITIES & INJURIES
my_health_summary_fatalities <- arrange(my_health_summary_fatalities, desc(SUM_FATALITIES))
my_health_summary_injuries <- arrange(my_health_summary_injuries, desc(SUM_INJURIES))
my_health_total_summary <- arrange(my_health_total_summary, desc(TOTAL))

# Preview
my_health_summary_fatalities
my_health_summary_injuries
my_health_total_summary

```


And now, we are going to check the more harmful event types with respect to economic consequences in our datasets.


```{r echo=TRUE, cache=TRUE}

# function to return the numeric exponent of given data type as is in the storm dataset
exponent.value <- function (param) sapply(param, function (c) switch (as.character(c), 
                                                                  "B"=1e9, "b" = 1e9, 
                                                                  "M"=1e6, "m" = 1e6, "k" = 1e3, "K"=1e3, 1))
# Group by event type
my_economic_group <- group_by(sub_data_economic, EVTYPE)






# Get the sum of injuries and fatalities by event type

my_economic_summary_propdmg <- summarise(my_health_group, sum(PROPDMG))
my_health_summary_injuries <- summarise(my_health_group, sum(INJURIES))
my_health_total_summary <- summarise(my_health_group, sum(FATALITIES),sum(INJURIES), 
                                     TOTAL = sum(FATALITIES) + sum(INJURIES))

# change tne column names
colnames(my_health_summary_fatalities) <- c("EVTYPE", "SUM_FATALITIES")
colnames(my_health_summary_injuries) <- c("EVTYPE", "SUM_INJURIES")
colnames(my_health_total_summary) <- c("EVTYPE", "SUM_FATALITIES", "SUM_INJURIES", "TOTAL")

# Order the dataset by number of FATALITIES & INJURIES
my_health_summary_fatalities <- arrange(my_health_summary_fatalities, desc(SUM_FATALITIES))
my_health_summary_injuries <- arrange(my_health_summary_injuries, desc(SUM_INJURIES))
my_health_total_summary <- arrange(my_health_total_summary, desc(TOTAL))

# Preview
#my_health_summary_fatalities
#my_health_summary_injuries
#my_health_total_summary

```
